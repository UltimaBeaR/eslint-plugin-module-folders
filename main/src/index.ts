import { ESLint } from "eslint";

import { parsedPackageJson } from "./internal/parsedPackageJson";
import { noNestedModulesRule } from "./rules/no-nested-modules";
import { correctImportsRule } from "./rules/correct-imports";

// TODO: переработка. Пока старый вариант забрасываю и оставляю его под тегом before rethinking
// новый вариант это ТОЛЬКО поддержка _module папок (либо сконигурировать другое имя)
// базовые правила - нельзя несколько вложенных модулей (на уровне текущего пути к файлу правило).
// при импорте нескольких вложенных модулей это воспринимается
// как ошибочный путь и не парсится.
// должна быть функция получающая абс путь (она уже есть) и функция разбивающая этот путь на сегменты и получающая
// информацию в виде структуры по этому пути.
// первое что надо получить - путь до приватной папки-модуля (папка _module) и далее - путь до папки модуля текущего файла.
// должно быть правило что папка выше приватной папки-модуля является папкой-модулем и все импорты из этой папки извне разрешены.
// при этом не важно индексный файл или нет. И также разрешены все импорты из этой папки в приватную папку.
// также разрешено делать импорт из приватной в приватную если это тот же модуль.
// также должен быть дополнительный конфиг юзерский в котором определяются дополнительные ограничения на импорт
// в том числе правила по fsd должны реализовываться там.
// в этом конфиге возможно будет что-то гибкое по типу что вот в такой то папке мы считаем что могут быть только папки-модули
// и не должно быть ничего кроме них (пока не знаю как это проверить без парсинга всех файлов в подпапке в файловой системе).
// также правила по слоям и правила запрета импорта из смежного сегмента
// думаю такие правила должны быть универсальными какими то атомарными правилами записаны с глоб паттернами
// и конфигами для каждой папки либо папки модуля. типа из такой то папки нельзя импортировать такие то папки и записывать это универсальным паттерном.
// правила порядка слоев и запрета импорта смежных слайсов лучше сделать через такие универсальные правила.

// TODO: должен быть конфиг позволяющий задать пути по которым плагин вообще проверяет импорты
// если это классический проект с src папкой то должен быть путь до этой папки
// чтобы если идет импорт на node-modules то чтобы там даже анализ не пытался происходить
// также могут быть проекты где в корне нет src папки а просто напиханы сразу файлы какие-то и их тоже надо анализировать, при
// этом на этом же уровне может быть node_modules
// нужно для такого сделать еще паттерны игнора, чтобы node_modules добавлять туда.
// можно сделать правила include / exclude - типа инклюдишь корень проекта (по дефолту) и эксплюдишь node_modules
// либо просто инклюдишь src и все.
// соответственно при анализе импортов если путь до импорта идет из папки которая не анализируется - то проверки правил на этот импорт
// игнорятся (так же как в случае если импорт на _module вложенный)

// TODO: при анализе импортов если есть вложенные модули, то анализируется только первый - можно так делать
// тогда без разницы будет есть там вложенные или нет - все внутренности считаются обычными папками.
// а отдельное правило на вложенности уже подсветит неправлиьные модули отдельно.

// TODO: попробовать сделать функционал автофикса там где он может понадобиться.

// TODO:
// отдельно по оформлению этой либы. Когда хотя бы базовый функционал правил импорта будет тут готов (без конфигов и т.д.)
// можно глянуть в либы для создания мультипакетных проектов и глянуть как их конфигурировать
// по типу lerna, turborepo, nx (скорее всего nx).
// надо бы по итогу автоматизировать пайплайн выкаток в нпм. сделать более удобный локальный запуск тестового проекта
// (его в отдельный пекедж) и сделать ts в коде плагина (т.к. сейчас js) плюс поддержку разных форматов модулей в npm пакете.

// TODO:
// Изучить альтернативы - плагин от fsd, плагин eslint-plugin-boundaries, imports плагин (может там что-то есть полезное)

// ----------------

// TODO: сделать кэш глобальный
// при проверках импортов - проходить по сегментам импортируемого пути и либо брать из кэша
// либо проходить по файлам (если кэша нет на этот сегмент пути - то есть под-папку) папки, парсить и создавать кэш
// если же выполняется правило для очередного файла - то этот файл сам тоже проверять и пересохранять в кэше, т.к.
// правила запускаются в том числе при изменениях файлов, соответственно любые изменения через ide приведут к
// обновлению кэша
// Либо другой вариант - ставить какой то вотчер изменений на файловую систему при инициализации.
//
// На каждый сегмент пути который учавствовал в импортах нужно делать кэш и в нем список файлов js/ts и пометки
// является ли этот файл паблик апи для папки-модуля
// Также для каждого имени файла абсолютного будет еще глобальная мапа для быстрого доступа по абсолютному имени файла к записи в кэше

console.log("module-folders init");

const plugin: ESLint.Plugin = {
  meta: {
    name: parsedPackageJson.name,
    version: parsedPackageJson.version,
  },

  rules: {
    "no-nested-modules": noNestedModulesRule,
    "correct-imports": correctImportsRule,
  },
};

module.exports = { ...plugin };
