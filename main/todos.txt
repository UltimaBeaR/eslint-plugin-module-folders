надо в кастомном правиле убрать возможность задавания нескольких функций. Кажется это ни к чему.

надо еще понять как поддерживать @x правила fsd - там же как то по хитрому надо понимать
что разрешено откуда импортить вроде. или нет хз. возможно придется усложнять контракт функции кастомной
и дополнительные данные туда передавать, например какую то функцию чтобы читать данные внутри модулей (с переиспользованием внутреннего кэша, если будет)
    хотя именно для @x - тут достаточно вроде знать имя файла импортируемого и имя модуля
    тогда можно вытащить относительное имя импортируемого файла относительно модуля (или его и надо бы знать)
    и по его пути понять - совпадает ли оно с именем модуля ОТКУДА импортируется файл или нет. если совпадает то можно импортить.
    при этом это все должно быть в пределах одного слайса где такое разрешено.
    Чтобы поддержать такое - нужно передавать кроме имени модулей еще и имя (можно относительное относительно модуля) того файла который импортится.
    А сейчас вроде только имя модуля передается.


    я вообще говоря думаю что надо переделать всю эту шляпу и сделать так:
    вызывать функцию проверки кастомную во всех случаях, даже если это не модули.
    если это модули - то передавать имена модулей дополнительно.
    а минимально -имена путей полные.
    если модуль передан то гарантированно полный путь включает имя модуля в начале.
    если модуль не передан то это всякие правила по типу импорт извне модуля в модуль и т.д.
    такое можно отдельно обрабатывать.
    запускать такие проверки только если импорт разрешен по дефолтным правилам папок-модулей.

в общем нужно уходить от вотчера. Можно делать кэш, но без вотчера.
Надо подумать могу ли я такое сделать.
Проблема будет если файлы меняются и это нигде не подхватывается.
Возможно как-то смотреть по сохраненной структуре файлов и смотреть время апдейта папок 
и если папка заапдейчена то пересчитывать ее. При каждом ране правила. Например.
Если такое вообще можно сделать.

    Можно. есть fs.statSync . fs.stat  -> stats.mtime
    это значение сохраняется у папок и файлов (дата модификации)
    и меняется при структурных изменениях - если файл добавляется то у всех родительских
    папок меняется mtime. так говорит нейронка но надо проверить.
    И нейронка говорит что во всех файловых системах так.
    Это не работает для изменени внутренностей файлов но мне это тут и не надо.
    Получается я могу при запуске правила, уже имея сеттинги - проходится по внутренностей
    структуре папок и создавать кэш, при этом создавать кэш с данными вообще всех папок и сохранять эти данные.
    При этом я могу хранить только те папки где есть внутри какие-нибудь файлы.
    И далее я могу делать просто так что пытаться пересчитать кэш файлов на каждый запуск правила
    и там будет доступ к файловой системе только на верхнеуровневых файлах если они не менялись
    у них получится mtime - увидит что они не менялись и внутрь заходить уже не будет - это будет оптимизация.
    Таким образом можно кэш этот сделать и реагировать на структурные изменения файлов, при этом Не делать вотчер.
    

стремный баг стал появляться после того как я сканирование файловой системы
запустил во время запуска правил.
по логам видно что один раз сканирование запускается
при этом кэш этот нигде не юзается - просто ранится сканирование.
И если сканирование не запускать то правила валидации в OtherPage на импорт MainPage
работают, но если запустить - то сначала срабатывают (кэш не юзаю) а потом через
секунду пропадают (перестала ошибка в правиле срабатывать)
как будто 2 раза прогоняется одно и то же правило и во 2 раз почему то перестало
видеть ошибку. Хз как так происходит. Видимо надо логи поставить в правила и продебажить
че происходит



Не забыть написать в ридми что надо ставить для того чтобы плагин работал
Кроме моего плагина тут нужен еще eslint-plugin-import и видимо еще
eslint-import-resolver-typescript а также надо в конфиге там настроить определенным
образом (я пока написал это в recommended конфиге, но это трудно как-то юзать)





https://github.com/import-js/eslint-plugin-import
и юзать из него https://www.npmjs.com/package/eslint-module-utils
для резолвинга файлов. Не юзать тайпскрипт напрямую.
На эту тему переписка в нейронке. также там последние 2 вопроса это на тему
include/exclude как раз.



Поидее мне надо брать tsconfig/jsconfig
и брать ихние include/exclude и переисопльзовать их
Если же заданы явные в плагине то юзать их.
Сейчас эти вещи в 2х местах уже юзаться должны - см.
по node_modules тексту.









я могу сделать в конфиге просто js функцию по типа canImport
которая должна вернуть true / undefined / null / что угодно еще, если импортировать можно
и false либо строку с текстом если импортировать нельзя (строка с текстом = сообщение об ошибке)
при этом в функцию передается относительный путь к модулю откуда идет импорт и относительный путь к модулю
куда идет импорт. Вызывается функция только если импорт идет из модуля в модуль - если одна из частей - не модуль то функция не дергается
и путь передается через массив сегментов (т.к. их легко превратить в путь и проще анализировать).

итого для fsd нужно будет прописать правила что можно только с определенного подпути в определенный импорттит как правила порядка слайсов
и прописать что внутри одного леера (только определенный список путей) нельзя импортировать из другого леера.
это императивным кодом делается супер-просто и быстро. короткая функция выйдет.
и будет поддерживать конкретный конфиг проекта при этом со всеми его сложными особенностями.
при этом можно будет даже сделать @правила для именованный импортов в entities таким образом
но там код посложнее будет.
Можно даже выпустить какой то отдельный пекедж про fsd который будет экспортировать этому
функцию в виде параметризированной фабрики, чтобы можно было такие fsd правила чекать.
    upd: нельзя функции передавать

также мысль что можно хранить файловый кеш при проверке принадлежит ли какой то путь какому то модулю-папке.
тут нужно будет проходиться по всем сегментам пути заданного - лезть в файловую систему и смотреть если ли в этом сегменте (папке) рядом _module папка - если да, то этот сегмент - имя модуля.

правило на ТОЛЬКО модули внутри определенной подпапки - тут придется анализировать файловую систему
чтобы проверить это и нужен будет файловый кэш. Но зато если это правило выключено то кэш можно этот не испльзовать для других правил так как там он не нужен.


правило на то что в определенной папке должны быть только модули
может работать по отдельным файлам - если он проверяет файл и видит
что этот файл - не в модуле-папке (получение codeFileInfo) но при этом его путь соответствует
паттерну папок которые должны содержать только модули - тогда он ругается.
то есть если прогнать все файлы в проекте на eslint то получится что если есть
хотя бы один кривой файл - то он его найдет. Так будет как раз соответсвовать
концепции еслинта.


Оформить package.json по аналогии с
    node_modules/eslint-plugin-react-hooks/package.json



// TODO: переработка. Пока старый вариант забрасываю и оставляю его под тегом before rethinking
// новый вариант это ТОЛЬКО поддержка _module папок (либо сконигурировать другое имя)
// базовые правила - нельзя несколько вложенных модулей (на уровне текущего пути к файлу правило).
// при импорте нескольких вложенных модулей это воспринимается
// как ошибочный путь и не парсится.
// должна быть функция получающая абс путь (она уже есть) и функция разбивающая этот путь на сегменты и получающая
// информацию в виде структуры по этому пути.
// первое что надо получить - путь до приватной папки-модуля (папка _module) и далее - путь до папки модуля текущего файла.
// должно быть правило что папка выше приватной папки-модуля является папкой-модулем и все импорты из этой папки извне разрешены.
// при этом не важно индексный файл или нет. И также разрешены все импорты из этой папки в приватную папку.
// также разрешено делать импорт из приватной в приватную если это тот же модуль.
// также должен быть дополнительный конфиг юзерский в котором определяются дополнительные ограничения на импорт
// в том числе правила по fsd должны реализовываться там.
// в этом конфиге возможно будет что-то гибкое по типу что вот в такой то папке мы считаем что могут быть только папки-модули
// и не должно быть ничего кроме них (пока не знаю как это проверить без парсинга всех файлов в подпапке в файловой системе).
// также правила по слоям и правила запрета импорта из смежного сегмента
// думаю такие правила должны быть универсальными какими то атомарными правилами записаны с глоб паттернами
// и конфигами для каждой папки либо папки модуля. типа из такой то папки нельзя импортировать такие то папки и записывать это универсальным паттерном.
// правила порядка слоев и запрета импорта смежных слайсов лучше сделать через такие универсальные правила.

// TODO: должен быть конфиг позволяющий задать пути по которым плагин вообще проверяет импорты
// если это классический проект с src папкой то должен быть путь до этой папки
// чтобы если идет импорт на node-modules то чтобы там даже анализ не пытался происходить
// также могут быть проекты где в корне нет src папки а просто напиханы сразу файлы какие-то и их тоже надо анализировать, при
// этом на этом же уровне может быть node_modules
// нужно для такого сделать еще паттерны игнора, чтобы node_modules добавлять туда.
// можно сделать правила include / exclude - типа инклюдишь корень проекта (по дефолту) и эксплюдишь node_modules
// либо просто инклюдишь src и все.
// соответственно при анализе импортов если путь до импорта идет из папки которая не анализируется - то проверки правил на этот импорт
// игнорятся (так же как в случае если импорт на _module вложенный)

// TODO: при анализе импортов если есть вложенные модули, то анализируется только первый - можно так делать
// тогда без разницы будет есть там вложенные или нет - все внутренности считаются обычными папками.
// а отдельное правило на вложенности уже подсветит неправлиьные модули отдельно.

// TODO: попробовать сделать функционал автофикса там где он может понадобиться.

// TODO:
// отдельно по оформлению этой либы. Когда хотя бы базовый функционал правил импорта будет тут готов (без конфигов и т.д.)
// можно глянуть в либы для создания мультипакетных проектов и глянуть как их конфигурировать
// по типу lerna, turborepo, nx (скорее всего nx).
// надо бы по итогу автоматизировать пайплайн выкаток в нпм. сделать более удобный локальный запуск тестового проекта
// (его в отдельный пекедж) и сделать ts в коде плагина (т.к. сейчас js) плюс поддержку разных форматов модулей в npm пакете.

// TODO:
// Изучить альтернативы - плагин от fsd, плагин eslint-plugin-boundaries, imports плагин (может там что-то есть полезное)

// ----------------

// TODO: сделать кэш глобальный
// при проверках импортов - проходить по сегментам импортируемого пути и либо брать из кэша
// либо проходить по файлам (если кэша нет на этот сегмент пути - то есть под-папку) папки, парсить и создавать кэш
// если же выполняется правило для очередного файла - то этот файл сам тоже проверять и пересохранять в кэше, т.к.
// правила запускаются в том числе при изменениях файлов, соответственно любые изменения через ide приведут к
// обновлению кэша
// Либо другой вариант - ставить какой то вотчер изменений на файловую систему при инициализации.
//
// На каждый сегмент пути который учавствовал в импортах нужно делать кэш и в нем список файлов js/ts и пометки
// является ли этот файл паблик апи для папки-модуля
// Также для каждого имени файла абсолютного будет еще глобальная мапа для быстрого доступа по абсолютному имени файла к записи в кэше
