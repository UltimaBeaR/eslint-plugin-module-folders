Поидее мне надо брать tsconfig/jsconfig
и брать ихние include/exclude и переисопльзовать их
Если же заданы явные в плагине то юзать их.
Сейчас эти вещи в 2х местах уже юзаться должны - см.
по node_modules тексту.









я могу сделать в конфиге просто js функцию по типа canImport
которая должна вернуть true / undefined / null / что угодно еще, если импортировать можно
и false либо строку с текстом если импортировать нельзя (строка с текстом = сообщение об ошибке)
при этом в функцию передается относительный путь к модулю откуда идет импорт и относительный путь к модулю
куда идет импорт. Вызывается функция только если импорт идет из модуля в модуль - если одна из частей - не модуль то функция не дергается
и путь передается через массив сегментов (т.к. их легко превратить в путь и проще анализировать).

итого для fsd нужно будет прописать правила что можно только с определенного подпути в определенный импорттит как правила порядка слайсов
и прописать что внутри одного леера (только определенный список путей) нельзя импортировать из другого леера.
это императивным кодом делается супер-просто и быстро. короткая функция выйдет.
и будет поддерживать конкретный конфиг проекта при этом со всеми его сложными особенностями.
при этом можно будет даже сделать @правила для именованный импортов в entities таким образом
но там код посложнее будет.
Можно даже выпустить какой то отдельный пекедж про fsd который будет экспортировать этому
функцию в виде параметризированной фабрики, чтобы можно было такие fsd правила чекать.
    upd: нельзя функции передавать

также мысль что можно хранить файловый кеш при проверке принадлежит ли какой то путь какому то модулю-папке.
тут нужно будет проходиться по всем сегментам пути заданного - лезть в файловую систему и смотреть если ли в этом сегменте (папке) рядом _module папка - если да, то этот сегмент - имя модуля.

правило на ТОЛЬКО модули внутри определенной подпапки - тут придется анализировать файловую систему
чтобы проверить это и нужен будет файловый кэш. Но зато если это правило выключено то кэш можно этот не испльзовать для других правил так как там он не нужен.


правило на то что в определенной папке должны быть только модули
может работать по отдельным файлам - если он проверяет файл и видит
что этот файл - не в модуле-папке (получение codeFileInfo) но при этом его путь соответствует
паттерну папок которые должны содержать только модули - тогда он ругается.
то есть если прогнать все файлы в проекте на eslint то получится что если есть
хотя бы один кривой файл - то он его найдет. Так будет как раз соответсвовать
концепции еслинта.


Оформить package.json по аналогии с
    node_modules/eslint-plugin-react-hooks/package.json



// TODO: переработка. Пока старый вариант забрасываю и оставляю его под тегом before rethinking
// новый вариант это ТОЛЬКО поддержка _module папок (либо сконигурировать другое имя)
// базовые правила - нельзя несколько вложенных модулей (на уровне текущего пути к файлу правило).
// при импорте нескольких вложенных модулей это воспринимается
// как ошибочный путь и не парсится.
// должна быть функция получающая абс путь (она уже есть) и функция разбивающая этот путь на сегменты и получающая
// информацию в виде структуры по этому пути.
// первое что надо получить - путь до приватной папки-модуля (папка _module) и далее - путь до папки модуля текущего файла.
// должно быть правило что папка выше приватной папки-модуля является папкой-модулем и все импорты из этой папки извне разрешены.
// при этом не важно индексный файл или нет. И также разрешены все импорты из этой папки в приватную папку.
// также разрешено делать импорт из приватной в приватную если это тот же модуль.
// также должен быть дополнительный конфиг юзерский в котором определяются дополнительные ограничения на импорт
// в том числе правила по fsd должны реализовываться там.
// в этом конфиге возможно будет что-то гибкое по типу что вот в такой то папке мы считаем что могут быть только папки-модули
// и не должно быть ничего кроме них (пока не знаю как это проверить без парсинга всех файлов в подпапке в файловой системе).
// также правила по слоям и правила запрета импорта из смежного сегмента
// думаю такие правила должны быть универсальными какими то атомарными правилами записаны с глоб паттернами
// и конфигами для каждой папки либо папки модуля. типа из такой то папки нельзя импортировать такие то папки и записывать это универсальным паттерном.
// правила порядка слоев и запрета импорта смежных слайсов лучше сделать через такие универсальные правила.

// TODO: должен быть конфиг позволяющий задать пути по которым плагин вообще проверяет импорты
// если это классический проект с src папкой то должен быть путь до этой папки
// чтобы если идет импорт на node-modules то чтобы там даже анализ не пытался происходить
// также могут быть проекты где в корне нет src папки а просто напиханы сразу файлы какие-то и их тоже надо анализировать, при
// этом на этом же уровне может быть node_modules
// нужно для такого сделать еще паттерны игнора, чтобы node_modules добавлять туда.
// можно сделать правила include / exclude - типа инклюдишь корень проекта (по дефолту) и эксплюдишь node_modules
// либо просто инклюдишь src и все.
// соответственно при анализе импортов если путь до импорта идет из папки которая не анализируется - то проверки правил на этот импорт
// игнорятся (так же как в случае если импорт на _module вложенный)

// TODO: при анализе импортов если есть вложенные модули, то анализируется только первый - можно так делать
// тогда без разницы будет есть там вложенные или нет - все внутренности считаются обычными папками.
// а отдельное правило на вложенности уже подсветит неправлиьные модули отдельно.

// TODO: попробовать сделать функционал автофикса там где он может понадобиться.

// TODO:
// отдельно по оформлению этой либы. Когда хотя бы базовый функционал правил импорта будет тут готов (без конфигов и т.д.)
// можно глянуть в либы для создания мультипакетных проектов и глянуть как их конфигурировать
// по типу lerna, turborepo, nx (скорее всего nx).
// надо бы по итогу автоматизировать пайплайн выкаток в нпм. сделать более удобный локальный запуск тестового проекта
// (его в отдельный пекедж) и сделать ts в коде плагина (т.к. сейчас js) плюс поддержку разных форматов модулей в npm пакете.

// TODO:
// Изучить альтернативы - плагин от fsd, плагин eslint-plugin-boundaries, imports плагин (может там что-то есть полезное)

// ----------------

// TODO: сделать кэш глобальный
// при проверках импортов - проходить по сегментам импортируемого пути и либо брать из кэша
// либо проходить по файлам (если кэша нет на этот сегмент пути - то есть под-папку) папки, парсить и создавать кэш
// если же выполняется правило для очередного файла - то этот файл сам тоже проверять и пересохранять в кэше, т.к.
// правила запускаются в том числе при изменениях файлов, соответственно любые изменения через ide приведут к
// обновлению кэша
// Либо другой вариант - ставить какой то вотчер изменений на файловую систему при инициализации.
//
// На каждый сегмент пути который учавствовал в импортах нужно делать кэш и в нем список файлов js/ts и пометки
// является ли этот файл паблик апи для папки-модуля
// Также для каждого имени файла абсолютного будет еще глобальная мапа для быстрого доступа по абсолютному имени файла к записи в кэше
